{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"The MIT License (MIT) \u00b6 Copyright \u00a9 2024 Nick Stockton Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#the-mit-license-mit","text":"Copyright \u00a9 2024 Nick Stockton Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"api/","text":"Knickknacks API \u00b6 Automatically generated API reference. Knickknacks \u00b6 Iterables Numbers Platforms Strings Testing Utils","title":"API Index"},{"location":"api/#knickknacks-api","text":"Automatically generated API reference.","title":"Knickknacks API"},{"location":"api/#knickknacks","text":"Iterables Numbers Platforms Strings Testing Utils","title":"Knickknacks"},{"location":"api/iterables/","text":"Module knickknacks.iterables \u00b6 Function average ( items ) \u00b6 Calculates the average item length of an iterable. Parameters: Name Type Description Default items Iterable[float] The iterable of items. required Returns: Type Description float The average item length. Source code in knickknacks/iterables.py def average ( items : Iterable [ float ]) -> float : \"\"\" Calculates the average item length of an iterable. Args: items: The iterable of items. Returns: The average item length. \"\"\" try : return statistics . mean ( items ) except statistics . StatisticsError : # No items. return 0 Function humanSort ( lst ) \u00b6 Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description list[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in knickknacks/iterables.py def humanSort ( lst : Sequence [ str ]) -> list [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], ) Function lpadList ( lst , padding , count , fixed = False ) \u00b6 Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in knickknacks/iterables.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ] Function padList ( lst , padding , count , fixed = False ) \u00b6 Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in knickknacks/iterables.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))]","title":"iterables.py"},{"location":"api/iterables/#knickknacks.iterables","text":"","title":"iterables"},{"location":"api/iterables/#knickknacks.iterables.average","text":"Calculates the average item length of an iterable. Parameters: Name Type Description Default items Iterable[float] The iterable of items. required Returns: Type Description float The average item length. Source code in knickknacks/iterables.py def average ( items : Iterable [ float ]) -> float : \"\"\" Calculates the average item length of an iterable. Args: items: The iterable of items. Returns: The average item length. \"\"\" try : return statistics . mean ( items ) except statistics . StatisticsError : # No items. return 0","title":"average()"},{"location":"api/iterables/#knickknacks.iterables.humanSort","text":"Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description list[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in knickknacks/iterables.py def humanSort ( lst : Sequence [ str ]) -> list [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], )","title":"humanSort()"},{"location":"api/iterables/#knickknacks.iterables.lpadList","text":"Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in knickknacks/iterables.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ]","title":"lpadList()"},{"location":"api/iterables/#knickknacks.iterables.padList","text":"Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in knickknacks/iterables.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))]","title":"padList()"},{"location":"api/numbers/","text":"Module knickknacks.numbers \u00b6 Function clamp ( value , minimum , maximum ) \u00b6 Clamps the given value between the given minimum and maximum values. Parameters: Name Type Description Default value float The value to restrict inside the range defined by minimum and maximum. required minimum float The minimum value to compare against. required maximum float The maximum value to compare against. required Returns: Type Description float The result between minimum and maximum. Source code in knickknacks/numbers.py def clamp ( value : float , minimum : float , maximum : float ) -> float : \"\"\" Clamps the given value between the given minimum and maximum values. Args: value: The value to restrict inside the range defined by minimum and maximum. minimum: The minimum value to compare against. maximum: The maximum value to compare against. Returns: The result between minimum and maximum. \"\"\" return minimum if value < minimum else maximum if value > maximum else value Function roundHalfAwayFromZero ( number , decimals = 0 ) \u00b6 Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in knickknacks/numbers.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number )","title":"numbers.py"},{"location":"api/numbers/#knickknacks.numbers","text":"","title":"numbers"},{"location":"api/numbers/#knickknacks.numbers.clamp","text":"Clamps the given value between the given minimum and maximum values. Parameters: Name Type Description Default value float The value to restrict inside the range defined by minimum and maximum. required minimum float The minimum value to compare against. required maximum float The maximum value to compare against. required Returns: Type Description float The result between minimum and maximum. Source code in knickknacks/numbers.py def clamp ( value : float , minimum : float , maximum : float ) -> float : \"\"\" Clamps the given value between the given minimum and maximum values. Args: value: The value to restrict inside the range defined by minimum and maximum. minimum: The minimum value to compare against. maximum: The maximum value to compare against. Returns: The result between minimum and maximum. \"\"\" return minimum if value < minimum else maximum if value > maximum else value","title":"clamp()"},{"location":"api/numbers/#knickknacks.numbers.roundHalfAwayFromZero","text":"Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in knickknacks/numbers.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number )","title":"roundHalfAwayFromZero()"},{"location":"api/platforms/","text":"Module knickknacks.platforms \u00b6 Function getDirectoryPath ( * args ) \u00b6 Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in knickknacks/platforms.py @lru_cache ( maxsize = None ) def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): # Use the location of the executable. path = os . path . dirname ( sys . executable ) else : # Use the location of the module which called this function. path = os . path . dirname ( inspect . stack ()[ 1 ] . filename ) return os . path . realpath ( os . path . join ( path , * args )) Function isFrozen () \u00b6 Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in knickknacks/platforms.py @lru_cache ( maxsize = None ) def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getattr ( sys , \"frozen\" , False ) or hasattr ( sys , \"importers\" ) or _imp . is_frozen ( \"__main__\" )) Function touch ( name ) \u00b6 Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in knickknacks/platforms.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"platforms.py"},{"location":"api/platforms/#knickknacks.platforms","text":"","title":"platforms"},{"location":"api/platforms/#knickknacks.platforms.getDirectoryPath","text":"Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in knickknacks/platforms.py @lru_cache ( maxsize = None ) def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): # Use the location of the executable. path = os . path . dirname ( sys . executable ) else : # Use the location of the module which called this function. path = os . path . dirname ( inspect . stack ()[ 1 ] . filename ) return os . path . realpath ( os . path . join ( path , * args ))","title":"getDirectoryPath()"},{"location":"api/platforms/#knickknacks.platforms.isFrozen","text":"Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in knickknacks/platforms.py @lru_cache ( maxsize = None ) def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getattr ( sys , \"frozen\" , False ) or hasattr ( sys , \"importers\" ) or _imp . is_frozen ( \"__main__\" ))","title":"isFrozen()"},{"location":"api/platforms/#knickknacks.platforms.touch","text":"Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in knickknacks/platforms.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"touch()"},{"location":"api/strings/","text":"Module knickknacks.strings \u00b6 Function camelCase ( text , delimiter ) \u00b6 converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in knickknacks/strings.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :]))) Function formatDocString ( functionOrString , width = 79 , prefix = None ) \u00b6 Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in knickknacks/strings.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString Function minIndent ( text ) \u00b6 Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in knickknacks/strings.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len ) Function multiReplace ( data , replacements ) \u00b6 Performs multiple replacement operations on a string or bytes-like object. Parameters: Name Type Description Default data BytesOrStr The text to perform the replacements on. required replacements Union[Sequence[Sequence[bytes]], Sequence[Sequence[str]]] A sequence of tuples, each containing the text to match and the replacement. required Returns: Type Description BytesOrStr The text with all the replacements applied. Source code in knickknacks/strings.py def multiReplace ( data : BytesOrStr , replacements : Union [ Sequence [ Sequence [ bytes ]], Sequence [ Sequence [ str ]]] ) -> BytesOrStr : \"\"\" Performs multiple replacement operations on a string or bytes-like object. Args: data: The text to perform the replacements on. replacements: A sequence of tuples, each containing the text to match and the replacement. Returns: The text with all the replacements applied. \"\"\" for item in replacements : data = data . replace ( * item ) return data Function regexFuzzy ( text ) \u00b6 Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in knickknacks/strings.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text ) Function removePrefix ( text , prefix ) \u00b6 Backport of removeprefix from PEP-616 (Python 3.9+) Source code in knickknacks/strings.py def removePrefix ( text : BytesOrStr , prefix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removeprefix` from PEP-616 (Python 3.9+)\"\"\" if text . startswith ( prefix ): return text [ len ( prefix ) :] else : return text Function removeSuffix ( text , suffix ) \u00b6 Backport of removesuffix from PEP-616 (Python 3.9+) Source code in knickknacks/strings.py def removeSuffix ( text : BytesOrStr , suffix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removesuffix` from PEP-616 (Python 3.9+)\"\"\" if suffix and text . endswith ( suffix ): return text [: - len ( suffix )] else : return text Function simplified ( text ) \u00b6 Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in knickknacks/strings.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip () Function stripAnsi ( text ) \u00b6 Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in knickknacks/strings.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text )","title":"strings.py"},{"location":"api/strings/#knickknacks.strings","text":"","title":"strings"},{"location":"api/strings/#knickknacks.strings.camelCase","text":"converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in knickknacks/strings.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :])))","title":"camelCase()"},{"location":"api/strings/#knickknacks.strings.formatDocString","text":"Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in knickknacks/strings.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString","title":"formatDocString()"},{"location":"api/strings/#knickknacks.strings.minIndent","text":"Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in knickknacks/strings.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len )","title":"minIndent()"},{"location":"api/strings/#knickknacks.strings.multiReplace","text":"Performs multiple replacement operations on a string or bytes-like object. Parameters: Name Type Description Default data BytesOrStr The text to perform the replacements on. required replacements Union[Sequence[Sequence[bytes]], Sequence[Sequence[str]]] A sequence of tuples, each containing the text to match and the replacement. required Returns: Type Description BytesOrStr The text with all the replacements applied. Source code in knickknacks/strings.py def multiReplace ( data : BytesOrStr , replacements : Union [ Sequence [ Sequence [ bytes ]], Sequence [ Sequence [ str ]]] ) -> BytesOrStr : \"\"\" Performs multiple replacement operations on a string or bytes-like object. Args: data: The text to perform the replacements on. replacements: A sequence of tuples, each containing the text to match and the replacement. Returns: The text with all the replacements applied. \"\"\" for item in replacements : data = data . replace ( * item ) return data","title":"multiReplace()"},{"location":"api/strings/#knickknacks.strings.regexFuzzy","text":"Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in knickknacks/strings.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text )","title":"regexFuzzy()"},{"location":"api/strings/#knickknacks.strings.removePrefix","text":"Backport of removeprefix from PEP-616 (Python 3.9+) Source code in knickknacks/strings.py def removePrefix ( text : BytesOrStr , prefix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removeprefix` from PEP-616 (Python 3.9+)\"\"\" if text . startswith ( prefix ): return text [ len ( prefix ) :] else : return text","title":"removePrefix()"},{"location":"api/strings/#knickknacks.strings.removeSuffix","text":"Backport of removesuffix from PEP-616 (Python 3.9+) Source code in knickknacks/strings.py def removeSuffix ( text : BytesOrStr , suffix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removesuffix` from PEP-616 (Python 3.9+)\"\"\" if suffix and text . endswith ( suffix ): return text [: - len ( suffix )] else : return text","title":"removeSuffix()"},{"location":"api/strings/#knickknacks.strings.simplified","text":"Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in knickknacks/strings.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip ()","title":"simplified()"},{"location":"api/strings/#knickknacks.strings.stripAnsi","text":"Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in knickknacks/strings.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text )","title":"stripAnsi()"},{"location":"api/testing/","text":"Module knickknacks.testing \u00b6 Class ContainerEmptyMixin \u00b6 A mixin class to be used in unit tests. Source code in knickknacks/testing.py class ContainerEmptyMixin : \"\"\" A mixin class to be used in unit tests. \"\"\" assertIsInstance : Callable [ ... , Any ] assertTrue : Callable [ ... , Any ] assertFalse : Callable [ ... , Any ] def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj ) Method assertContainerEmpty ( self , obj ) \u00b6 Asserts whether the given object is an empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in knickknacks/testing.py def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) Method assertContainerNotEmpty ( self , obj ) \u00b6 Asserts whether the given object is a non-empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in knickknacks/testing.py def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj )","title":"testing.py"},{"location":"api/testing/#knickknacks.testing","text":"","title":"testing"},{"location":"api/testing/#knickknacks.testing.ContainerEmptyMixin","text":"A mixin class to be used in unit tests. Source code in knickknacks/testing.py class ContainerEmptyMixin : \"\"\" A mixin class to be used in unit tests. \"\"\" assertIsInstance : Callable [ ... , Any ] assertTrue : Callable [ ... , Any ] assertFalse : Callable [ ... , Any ] def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj )","title":"ContainerEmptyMixin"},{"location":"api/testing/#knickknacks.testing.ContainerEmptyMixin.assertContainerEmpty","text":"Asserts whether the given object is an empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in knickknacks/testing.py def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj )","title":"assertContainerEmpty()"},{"location":"api/testing/#knickknacks.testing.ContainerEmptyMixin.assertContainerNotEmpty","text":"Asserts whether the given object is a non-empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in knickknacks/testing.py def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj )","title":"assertContainerNotEmpty()"},{"location":"api/utils/","text":"Module knickknacks.utils \u00b6 Function page ( lines ) \u00b6 Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in knickknacks/utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text )","title":"utils.py"},{"location":"api/utils/#knickknacks.utils","text":"","title":"utils"},{"location":"api/utils/#knickknacks.utils.page","text":"Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in knickknacks/utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text )","title":"page()"}]}